<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL व्यूअर और वेट कैलकुलेटर</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        #viewer-container {
            flex-grow: 1;
            position: relative;
            background-color: #e2e8f0; /* Lighter blue-gray for viewer */
            border-radius: 0.75rem; /* Rounded corners */
            overflow: hidden;
            min-height: 300px; /* Minimum height for viewer */
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 0.75rem;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Blue spinner */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">
    <div class="max-w-4xl mx-auto w-full bg-white rounded-xl shadow-lg p-6 space-y-6">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">STL व्यूअर और वेट कैलकुलेटर</h1>

        <!-- File Input Section -->
        <div class="flex flex-col items-center justify-center p-4 border-2 border-dashed border-blue-300 rounded-lg bg-blue-50">
            <label for="stlFileInput" class="cursor-pointer flex items-center space-x-2 text-blue-700 font-medium">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                <span>STL फ़ाइल चुनें</span>
            </label>
            <input type="file" id="stlFileInput" accept=".stl" class="hidden">
            <p id="fileNameDisplay" class="mt-2 text-sm text-gray-600"></p>
        </div>

        <!-- 3D Viewer Container -->
        <div id="viewer-container" class="relative w-full h-80 md:h-96 lg:h-[500px] mb-6">
            <div id="loading-overlay" class="hidden">
                <div class="spinner"></div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Dimensions Card -->
            <div class="bg-blue-100 p-5 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold text-blue-800 mb-3">डाइमेंशन (मिमी में)</h2>
                <p class="text-gray-700">X: <span id="dimX" class="font-medium">--</span> मिमी</p>
                <p class="text-gray-700">Y: <span id="dimY" class="font-medium">--</span> मिमी</p>
                <p class="text-gray-700">Z: <span id="dimZ" class="font-medium">--</span> मिमी</p>
            </div>

            <!-- Weight Card -->
            <div class="bg-green-100 p-5 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold text-green-800 mb-3">पीतल का वज़न (ग्राम में)</h2>
                <p class="text-gray-700">वॉल्यूम: <span id="volume" class="font-medium">--</span> मिमी³</p>
                <p class="text-gray-700">वज़न: <span id="weight" class="font-medium">--</span> ग्राम</p>
                <p class="text-sm text-gray-600 mt-2">पीतल का घनत्व: 8.5 ग्राम/सेमी³</p>
            </div>
        </div>

        <!-- Instructions -->
        <div class="mt-8 p-5 bg-gray-50 rounded-lg shadow-inner">
            <h2 class="text-xl font-semibold text-gray-700 mb-3">कैसे इस्तेमाल करें:</h2>
            <ul class="list-disc list-inside text-gray-600 space-y-2">
                <li>ऊपर दिए गए "STL फ़ाइल चुनें" बटन पर क्लिक करें.</li>
                <li>अपने डिवाइस से एक .stl फ़ाइल चुनें.</li>
                <li>फ़ाइल लोड होने के बाद, आप 3D मॉडल को देखने के लिए माउस (या टच) का उपयोग कर सकते हैं:
                    <ul class="list-disc list-inside ml-5 mt-1">
                        <li>**रोटेट (Rotate):** माउस के बाएं बटन को दबाकर ड्रैग करें (या एक उंगली से स्वाइप करें).</li>
                        <li>**पैन (Pan):** माउस के दाएं बटन को दबाकर ड्रैग करें (या दो उंगलियों से स्वाइप करें).</li>
                        <li>**ज़ूम (Zoom):** माउस व्हील का उपयोग करें (या दो उंगलियों से पिंच करें).</li>
                    </ul>
                </li>
                <li>डाइमेंशन और वज़न की जानकारी नीचे प्रदर्शित होगी.</li>
            </ul>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- STLLoader for loading STL files -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // Firebase configuration (will be provided by Canvas environment)
        // const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        // const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Scene setup
        let scene, camera, renderer, controls;
        let currentMesh; // To keep track of the currently loaded mesh

        const viewerContainer = document.getElementById('viewer-container');
        const stlFileInput = document.getElementById('stlFileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const dimXSpan = document.getElementById('dimX');
        const dimYSpan = document.getElementById('dimY');
        const dimZSpan = document.getElementById('dimZ');
        const volumeSpan = document.getElementById('volume');
        const weightSpan = document.getElementById('weight');

        // Brass density in g/cm³
        const BRASS_DENSITY_G_PER_CM3 = 8.5;

        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // Light background for the 3D scene

            // Camera
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 100); // Initial camera position

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // White directional light
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // OrbitControls (for pan, rotate, zoom)
            controls = new THREE.OrbitControls(camera, viewerContainer);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = true; // Pan in screen space
            controls.update(); // Must be called after any manual changes to the camera's transform

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Initial call to set size correctly
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            controls.update(); // Update controls on resize
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping or controls.autoRotate are set to true
            renderer.render(scene, camera);
        }

        // Function to calculate volume of a mesh
        // This method sums the signed volumes of tetrahedrons formed by each triangle and the origin.
        // Assumes geometry is non-indexed or converts indexed to non-indexed for iteration.
        function calculateVolume(geometry) {
            if (!geometry.isBufferGeometry) {
                console.error("Geometry is not a BufferGeometry.");
                return 0;
            }

            let volume = 0;
            const position = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;

            const pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3();

            if (indices) {
                // Indexed geometry
                for (let i = 0; i < indices.length; i += 3) {
                    const iA = indices[i] * 3;
                    const iB = indices[i + 1] * 3;
                    const iC = indices[i + 2] * 3;

                    pA.set(position[iA], position[iA + 1], position[iA + 2]);
                    pB.set(position[iB], position[iB + 1], position[iB + 2]);
                    pC.set(position[iC], position[iC + 1], position[iC + 2]);

                    volume += pA.dot(pB.cross(pC));
                }
            } else {
                // Non-indexed geometry
                for (let i = 0; i < position.length; i += 9) {
                    pA.set(position[i], position[i + 1], position[i + 2]);
                    pB.set(position[i + 3], position[i + 4], position[i + 5]);
                    pC.set(position[i + 6], position[i + 7], position[i + 8]);

                    volume += pA.dot(pB.cross(pC));
                }
            }

            return Math.abs(volume / 6); // Volume is 1/6 of the sum of dot products
        }


        // Function to load STL file
        function loadSTL(file) {
            loadingOverlay.classList.remove('hidden'); // Show loading spinner
            fileNameDisplay.textContent = `लोड हो रहा है: ${file.name}...`;
            resetResults();

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(event.target.result);

                    // If the geometry is not a BufferGeometry (e.g., from an older STL loader), convert it.
                    // This ensures `calculateVolume` works correctly.
                    if (!(geometry instanceof THREE.BufferGeometry)) {
                        geometry = new THREE.BufferGeometry().fromGeometry(geometry);
                    }

                    // Calculate bounding box for dimensions
                    geometry.computeBoundingBox();
                    const bbox = geometry.boundingBox;
                    const dimensions = new THREE.Vector3().subVectors(bbox.max, bbox.min);

                    // Create material
                    const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 }); // Metallic look

                    // Create mesh
                    const mesh = new THREE.Mesh(geometry, material);

                    // Clear previous mesh if any
                    if (currentMesh) {
                        scene.remove(currentMesh);
                        currentMesh.geometry.dispose();
                        currentMesh.material.dispose();
                    }
                    currentMesh = mesh;
                    scene.add(currentMesh);

                    // Center the model in the scene
                    const center = new THREE.Vector3();
                    bbox.getCenter(center);
                    mesh.position.sub(center); // Move mesh so its center is at (0,0,0)

                    // Adjust camera to fit the model
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    const distance = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5; // Add some padding
                    camera.position.set(0, 0, distance);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.update();

                    // Display dimensions (assuming units are in mm as STL doesn't define units)
                    dimXSpan.textContent = dimensions.x.toFixed(2);
                    dimYSpan.textContent = dimensions.y.toFixed(2);
                    dimZSpan.textContent = dimensions.z.toFixed(2);

                    // Calculate volume (in mm³)
                    const volumeMM3 = calculateVolume(geometry);
                    volumeSpan.textContent = volumeMM3.toFixed(2);

                    // Calculate weight (convert volume from mm³ to cm³ first)
                    // 1 cm³ = 1000 mm³
                    const volumeCM3 = volumeMM3 / 1000;
                    const weightGrams = volumeCM3 * BRASS_DENSITY_G_PER_CM3;
                    weightSpan.textContent = weightGrams.toFixed(2);

                    fileNameDisplay.textContent = `फ़ाइल लोड हुई: ${file.name}`;

                } catch (error) {
                    console.error("STL फ़ाइल लोड करने या पार्स करने में त्रुटि:", error);
                    fileNameDisplay.textContent = `त्रुटि: फ़ाइल लोड नहीं हो सकी. कृपया एक वैध STL फ़ाइल चुनें.`;
                    resetResults();
                } finally {
                    loadingOverlay.classList.add('hidden'); // Hide loading spinner
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Reset displayed results
        function resetResults() {
            dimXSpan.textContent = '--';
            dimYSpan.textContent = '--';
            dimZSpan.textContent = '--';
            volumeSpan.textContent = '--';
            weightSpan.textContent = '--';
        }

        // Event listener for file input
        stlFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                if (file.name.toLowerCase().endsWith('.stl')) {
                    loadSTL(file);
                } else {
                    fileNameDisplay.textContent = 'कृपया एक .stl फ़ाइल चुनें.';
                    resetResults();
                }
            } else {
                fileNameDisplay.textContent = '';
                resetResults();
            }
        });

        // Initialize the 3D scene when the window loads
        window.onload = function() {
            init();
            animate();
            resetResults(); // Clear initial placeholder text
        };
    </script>
</body>
</html>

